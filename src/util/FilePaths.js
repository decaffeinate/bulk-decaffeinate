import executable from 'executable';
import { readFile } from 'mz/fs';
import { basename, dirname, extname, join } from 'path';

export const COFFEE_FILE_RECOGNIZER = {
  extensions: ['.coffee', '.litcoffee', '.coffee.md'],
  shebangSuffix: 'coffee',
};

export const JS_FILE_RECOGNIZER = {
  extensions: ['.js'],
  shebangSuffix: 'node',
};

function extensionFor(path) {
  if (path.endsWith('.coffee.md')) {
    return '.coffee.md';
  }
  return extname(path);
}

function basePathFor(path) {
  let extension = extensionFor(path);
  return join(dirname(path), basename(path, extension));
}

export async function shouldConvertFile(path, recognizer, trackedFiles) {
  if (!hasRecognizedExtension(path, recognizer) &&
      !await isExecutableScript(path, recognizer)) {
    return false;
  }
  if (!trackedFiles.has(path)) {
    console.log(
      `Warning: Skipping ${path} because the file is not tracked in the git repo.`);
    return false;
  }
  return true;
}

function hasRecognizedExtension(path, recognizer) {
  return recognizer.extensions.some(ext =>
    path.endsWith(ext) && !path.endsWith(`.original${ext}`));
}

async function isExecutableScript(path, recognizer) {
  if (isExtensionless(path) && await executable(path)) {
    let contents = await readFile(path);
    let firstLine = contents.toString().split('\n')[0];
    if (firstLine.startsWith('#!') && firstLine.includes(recognizer.shebangSuffix)) {
      return true;
    }
  }
  return false;
}

export function isExtensionless(path) {
  return extensionFor(path) === '';
}

export function backupPathFor(path) {
  let extension = extensionFor(path);
  let basePath = basePathFor(path);
  return basePath + '.original' + extension;
}

/**
 * The resulting path where we should send the given input file. Note that when
 * the input file is an extensionless script, we prefer to keep it extensionless
 * (and decaffeinate handles the shebang line).
 */
export function jsPathFor(path, config) {
  if (config.customNames[path]) {
    return config.customNames[path];
  }
  if (isExtensionless(path)) {
    return path;
  } else {
    return basePathFor(path) + '.' + config.outputFileExtension;
  }
}

/**
 * The file generated by decaffeinate for the input file with this name.
 */
export function decaffeinateOutPathFor(path) {
  return basePathFor(path) + '.js';
}

export function isLiterate(path) {
  return path.endsWith('.litcoffee') || path.endsWith('.coffee.md');
}
